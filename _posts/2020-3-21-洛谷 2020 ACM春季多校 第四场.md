---
title: 洛谷 2020 ACM春季多校 第四场
tags:
  - C++
  - ACM
  - 算法竞赛
  - 洛谷
---

## 洛谷 2020 ACM春季多校 第四场

F.	God J and Firm Structure

题意：给你n个点，让你画任意条边，使得这张图删掉任意k-1条边都保持连通，但是当删掉任意k条边的时候存在不连通的情况，问你最少要画几条边：

分析：

$$
特殊情况：当k=1时，该图为一棵生成树，边为n-1。
\\
一般情况：设图中点的最小度数为\delta,那么一定有|E| = \frac{1}{2}\sum d(u) \geq  n\delta \geq \frac{nk}{2}，也就是说|E|的下界为\frac{nk}{2}。
\\
给出1组能够达到下界的构造：
\\
当k为偶数的时候，设k=2r，则有e_{ij} = 1<==> (j-i+r)mod \ n \leq 2r,也就是把所有点都排成环，然后在间隔不超过r之间的\\点上连边。
\\
当k为奇数、n为偶数的时候，设k=2r+1，则构造（k-1，n）的情况，然后对\forall i\epsilon[0,\frac{n}{2}-1],连接i和i+\frac{n}{2}。
\\
当k为奇数、n为奇数的时候，设k=2r+1，则同样构造（k-1，n）的情况，然后连接（i，i+\frac{n+1}{2}）(0\le i < \frac{n-1}{2}),\\再连接（0，\frac{n-1}{2}）。
\\
最后得出答案\lceil\frac{nk}{2}\rceil
$$


```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, k, T;
int main()
{
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d", &n, &k);
        if (k == 1)
            printf("%d\n", n - 1);
        else
        {
            ll ans = (ll)n * k;
            if (ans & 1)
                ans = ans / 2 + 1;
            else
                ans = ans / 2;
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```

E、God J and Eel

题意：按时间顺序给出操作，有为某人添加一个到某某时间为止的DDL、在某个时间点询问某人最新添加的DDL、询问某人的某个DDL是否过期。

分析：简单模拟

```c++
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
struct node
{
    string ddl;
    int ti;
} t;
vector<node> v[1010];
vector<node>::iterator it;
vector<node>::iterator it1;
int n, m;
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int op;
        scanf("%d", &op);
        if (op == 1)
        {
            int x;
            string ddl;
            int edtime;
            scanf("%d", &x);
            cin >> ddl;
            scanf("%d", &edtime);

            v[x].push_back(node{ddl, edtime});
        }
        else if (op == 2)
        {
            int x;
            scanf("%d", &x);

            int minti = inf;
            string ans = "";
            int flag = 0;

            for (it = v[x].begin(); it != v[x].end(); it++)
            {
                node temp = *it;
                //            	cout<<"ti="<<temp.ti<<" string="<<temp.ddl<<endl;
                if (temp.ti >= i)
                {
                    if (temp.ti < minti)
                    {
                        //            			cout<<"minti="<<minti<<endl;
                        minti = temp.ti;
                        ans = temp.ddl;
                        flag = 1;
                    }
                }
            }
            if (!flag)
                printf("Happy\n");
            else
                cout << ans << endl;
        }
        else if (op == 3)
        {
            int x;
            string s;
            scanf("%d", &x);
            cin >> s;

            int flag = 0;
            for (it1 = v[x].begin(); it1 != v[x].end(); it1++)
            {
                node temp = (*it1);
                if (i > temp.ti)
                    continue;
                if (temp.ddl == s)
                {
                    flag = 1;
                    break;
                }
            }
            if (flag)
                printf("OK\n");
            else
                printf("GG\n");
        }
    }
    return 0;
}
```

