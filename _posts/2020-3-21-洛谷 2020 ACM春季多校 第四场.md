---
title: 洛谷 2020 ACM春季多校 第四场
tags:
  - C++
  - ACM
  - 算法竞赛
  - 洛谷
---

## 洛谷 2020 ACM春季多校 第四场

A.	God J and Ancient Tree

题意：给一棵树，有点权，求两条到根的链，使得他们的并上点权异或值最大。

分析：考虑枚举分叉点，那么可以同时往两个方向延伸，每个方向都有很多种选择，问题就变成了询问两
个集合的最大异或和。这个问题可以建立一边的 trie 树，然后在另一边挨个询问解决。回到原问题，如果知道分叉点其中一个方向的所有可能形成的 trie 树，那对另一个方向挨个暴力询问一次就行了。因此问题在怎么求一棵子树所对应的 trie 树。可以使用启发式合并或者 dsu on tree，都可做到O(n logn logn)

这题没能够理解。。。。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 7;
int n, a[maxn], answer = 0, fa[maxn], son[maxn], sze[maxn];
vector<int> g[maxn];
void dfs1(int x, int pre)
{
    fa[x] = pre;
    sze[x] = 1;
    son[x] = 0;
    for (auto v : g[x])
        if (v != fa[x])
        {
            dfs1(v, x);
            sze[x] += sze[v];
            if (!son[x] || sze[son[x]] < sze[v])
                son[x] = v; //son[x]记录容量最大的儿子
        }
}
int pc = 1, ch[maxn * 40][2];
void clear()
{
    pc = 1, ch[1][0] = ch[1][1] = 0;
}
void insert(int x)
{
    int cur = 1;
    for (int i = 29; ~i; i--)
    {
        if (!ch[cur][x >> i & 1])
        {
            ch[cur][x >> i & 1] = ++pc;
            ch[pc][0] = ch[pc][1] = 0;
        }
        cur = ch[cur][x >> i & 1];
    }
}
int ask(int x)
{
    if (pc == 1)
        return x;
    int ans = 0, cur = 1;
    for (int i = 29; ~i; i--)
        if (ch[cur][!(x >> i & 1)])
        {
            ans |= 1 << i;
            cur = ch[cur][!(x >> i & 1)];
        }
        else
            cur = ch[cur][x >> i & 1];
    return ans;
}
void dfs3(int x, int cur)
{
    answer = max(answer, ask(cur));
    for (auto v : g[x])
        if (v != fa[x])
            dfs3(v, cur ^ a[v]);
}
void dfs4(int x, int cur)
{
    insert(cur);
    for (auto v : g[x])
        if (v != fa[x])
            dfs4(v, cur ^ a[v]);
}
void dfs2(int x, int cur, bool keep)
{
    answer = max(answer, cur);
    for (auto v : g[x])
        if (v != fa[x] && v != son[x])
            dfs2(v, cur ^ a[v], false);
    if (son[x])
        dfs2(son[x], cur ^ a[son[x]], true);
    else
        clear();
    for (auto v : g[x])
        if (v != fa[x] && v != son[x])
            dfs3(v, a[v]), dfs4(v, cur ^ a[v]);
    if (keep)
        insert(cur);
    else
        clear();
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 1, u, v; i < n; i++)
    {
        scanf("%d %d", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs1(1, 0);
    dfs2(1, a[1], false);
    printf("%d", answer);
    return 0;
}
```



B.	God J and Blooming Gentians

题意：给你n*m的矩阵，每次随机选择一种颜色删去，删去的同时，与其他颜色不相邻的颜色也会被删
去。问期望选择删几次后所有颜色都被删完。

分析：将颜色视为点，颜色相邻就连一条边，问题变为每次选择一个非孤立点删去连接它的边，期望多少次之后所有点都孤立。

![1581826760296](\JODE-HRK.github.io\assets\image\God J and Blooming Gentians.jpg)

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 7, mod = 1e9 + 7;
int n, m, c;
int d[maxn];
int g[1001][1001];
set<int> M[maxn]; //set不会记录重复的数
int ppow(int x, int y)
{
    int sum = 1;
    while (y)
    {
        if (y & 1)
            sum = 1ll * sum * x % mod;
        y >>= 1;
        x = 1ll * x * x % mod;
    }
    return sum;
}
int main()
{
    int mn = mod, mx = -mod;
    scanf("%d %d %d", &n, &m, &c);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &g[i][j]), mn = min(mn, g[i][j]), mx = max(mx, g[i][j]);
    if (mn == mx) //没有相连的时候，概率期望值就是1
    {
        cout << "1";
        return 0;
    }
    for (int i = 1; i <= c; i++)
        M[i].insert(i);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            if (i > 1)
                M[g[i][j]].insert(g[i - 1][j]);
            if (i < n)
                M[g[i][j]].insert(g[i + 1][j]);
            if (j > 1)
                M[g[i][j]].insert(g[i][j - 1]);
            if (j < m)
                M[g[i][j]].insert(g[i][j + 1]);
        }
    int ans = 0;
    for (int i = 1; i <= c; i++)
        ans = (ans + ppow(M[i].size(), mod - 2)) % mod; //逆元
    printf("%d", (c - ans + mod) % mod);
    return 0;
}
```



F.	God J and Firm Structure

题意：给你n个点，让你画任意条边，使得这张图删掉任意k-1条边都保持连通，但是当删掉任意k条边的时候存在不连通的情况，问你最少要画几条边：

分析：
$$
特殊情况：当k=1时，该图为一棵生成树，边为n-1。
\\
一般情况：设图中点的最小度数为\delta,那么一定有
\\|E| = \frac{1}{2}\sum d(u) \geq  n\delta \geq \frac{nk}{2}，也就是说|E|的下界为\frac{nk}{2}。
\\
给出1组能够达到下界的构造：
\\
当k为偶数的时候，设k=2r，则有
\\e_{ij} = 1<==> (j-i+r)mod \ n \leq 2r,
\\也就是把所有点都排成环，然后在间隔不超过r之间的点上连边。
\\
当k为奇数、n为偶数的时候，设k=2r+1，\\则构造（k-1，n）的情况，然后对\forall i\epsilon[0,\frac{n}{2}-1],连接i和i+\frac{n}{2}。
\\
当k为奇数、n为奇数的时候，设k=2r+1，\\则同样构造（k-1，n）的情况，\\然后连接（i，i+\frac{n+1}{2}）(0\le i < \frac{n-1}{2}),再连接（0，\frac{n-1}{2}）。
\\
最后得出答案\lceil\frac{nk}{2}\rceil
$$


```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, k, T;
int main()
{
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d", &n, &k);
        if (k == 1)
            printf("%d\n", n - 1);
        else
        {
            ll ans = (ll)n * k;
            if (ans & 1)
                ans = ans / 2 + 1;
            else
                ans = ans / 2;
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```

E、God J and Eel

题意：按时间顺序给出操作，有为某人添加一个到某某时间为止的DDL、在某个时间点询问某人最新添加的DDL、询问某人的某个DDL是否过期。

分析：简单模拟

```c++
#include <bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
struct node
{
    string ddl;
    int ti;
} t;
vector<node> v[1010];
vector<node>::iterator it;
vector<node>::iterator it1;
int n, m;
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int op;
        scanf("%d", &op);
        if (op == 1)
        {
            int x;
            string ddl;
            int edtime;
            scanf("%d", &x);
            cin >> ddl;
            scanf("%d", &edtime);

            v[x].push_back(node{ddl, edtime});
        }
        else if (op == 2)
        {
            int x;
            scanf("%d", &x);

            int minti = inf;
            string ans = "";
            int flag = 0;

            for (it = v[x].begin(); it != v[x].end(); it++)
            {
                node temp = *it;
                //            	cout<<"ti="<<temp.ti<<" string="<<temp.ddl<<endl;
                if (temp.ti >= i)
                {
                    if (temp.ti < minti)
                    {
                        //            			cout<<"minti="<<minti<<endl;
                        minti = temp.ti;
                        ans = temp.ddl;
                        flag = 1;
                    }
                }
            }
            if (!flag)
                printf("Happy\n");
            else
                cout << ans << endl;
        }
        else if (op == 3)
        {
            int x;
            string s;
            scanf("%d", &x);
            cin >> s;

            int flag = 0;
            for (it1 = v[x].begin(); it1 != v[x].end(); it1++)
            {
                node temp = (*it1);
                if (i > temp.ti)
                    continue;
                if (temp.ddl == s)
                {
                    flag = 1;
                    break;
                }
            }
            if (flag)
                printf("OK\n");
            else
                printf("GG\n");
        }
    }
    return 0;
}
```

