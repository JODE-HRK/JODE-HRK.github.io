---
title: C++面试基础知识集合
tags:
  - 面试
  - C++
---

# C++面试基础知识集合

**一、变量的声明和定义**

​	定义：为变量分配地址和存储空间

​	声明：不分配地址

​	一个变量可以在多个地方声明，但只在一个地方定义。

​	使用**extern**修饰的变量的声明，说明此变量在文件以外或在文件后面部分定义。

​	说明：很多时候一个变量，只是声明不分配内存空间，知道具体使用时才初始化，分配内存空间。如外部变量。

**二、sizeof和strlen的区别**

​	sizeof是一个操作符，strlen是库函数。

​	sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为 '\0' 的字符串做参数

​	编译器在编译时就计算出sizeof的结果，而strlen函数必须在运算时才能计算出来。sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串的实际长度。

**三、C++的关键字static有什么作用**

- 什么是static？
  - C++中很常用的的修饰符，用来控制变量和存储方式和可见性
- 为什么要引入static？
  - 函数内部定义的变量，在程序执行到其定义处会为其分配一个空间，而函数在栈上分配的空间在函数结束时会释放掉，那么就产生了一个问题：如果想将函数中此变量的值保存至下一次调用时，如何实现？最容易想到的方法就是定义一个全局变量，但定义一个**全局变量**有许多缺点，最明显的就是**破坏了此变量的访问范围**（使得在此函数中定义的该变量，不仅仅受此函数控制）。那么此时，我们就需要引入static
- 什么时候使用static？
  - 需要一个数据对象为整个类而非某一个对象服务，同时有**力求不破坏类的封装性**。即要求此成员隐藏在类的内部，对外不可见。
- static的内部机制：
  - 静态数据成员要在程序一开始就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
  - 静态数据成员的空间分配由三个可能的地方，一是作为类的外部接口的头文件，此处由类声明；二是类定义的内部实现，那里有类的成员函数定义；三是全局数据声明和定义处。
  - tips:由于静态数据成员要实际的分配空间，故不能在类的声明处定义（只能声明数据成员）。类声明只声明一个类的尺寸和规格，并不进行实际的内存分配。也不能在头文件中类声明的外部定义，因为会造成在多个使用该类的源文件中对其重复定义。
  - static被引入后告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按照定义时的顺序一次初始化。
- static的优势：
  - 节省内存，其对所有对象共有，因此，对多个对象来说，静态数据只存在在于一处，供所有对象使用。静态数据成员的值对每一个对象都一样，而且它的值时可以更新的，每一次更新后，其后所有调用的对象都是使用的新值，这样可以提高时间效率。
  - static没有增加程序的时空开销，相反其还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。
- static的局限性：
  - 类的静态成员函数是整个类而非类的对象，所以其没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数
  - 无法将静态成员函数定义为虚函数
  - 因为静态成员函数声明于类中，操作于其外，所以对静态成员函数取地址就稍显特殊，变量地址是指向其数据类型的指针，函数地址类型是一个“nonmember函数指针。”

**四、volatile（易变的）关键字**

​	volatile关键字和const关键字对应，volatile表示类型变量表示被某些编译器更改。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。（优化：两次读取之间没有发向对变量的修改，那么就会直接使用上次读的数据）也就是说，使用volatile修饰的变量，每次使用的时候都会再一次直接从其地址读取数据，避免了一些特殊情况下的出错。

由此可知volatile关键字一需要使用的几种情况：

- 中断服务程序中修改的供其他程序检测的变量
- 多任务环境中各任务之间共享的标志变量（多线程）
- 存储器映射的硬件寄存器通常也需要使用volatile，因为每次读写都可能有不同意义

**五、C++程序编译的内存分配情况**

​	内存分配方式一般可分为三种

- 从静态存储区域分配：
  - 内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。
  - 优点：速度快、不易出错，因为由系统会善后。例如全局变量，static变量等
- 从栈上分配：
  - 在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时，这些存储单元自动释放。
  - 优点：栈内存分配算法内置于处理器的指令集中，效率高
  - 缺陷：分配的内存容量有限。
- 从堆上分配：
  - 即动态内存分配。程序在运行的时候使用malloc或new申请任意大小的内存，由程序员自己负责在何时使用free或delete释放内存。动态内存的生存期由程序员决定，使用灵活。如果堆上分配了空间，就有责任回收它，否则程序会出现内存泄漏，此外，频繁的分配和释放不同大小的堆空间将会产生堆内碎块。

Tips：

- C++程序编译时，内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区
- 程序的局部变量存在于栈中，全局变量存在于静态存储区，动态申请数据存在于堆中。

**六、strcpy、sprintf与memcpy的区别**

- 操作对象不同，strcpy的两个操作对象均为字符串，sprintf的操作对象可以是多种数据类型
- 执行效率不同，memcpy最高，strcpy次之，sprintf最低
- 实现功能不同，strcpy主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型到字符串类型的转换，memcpy主要是内存块之间的拷贝。

Tips：strcpy、sprintf与memcpy都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能

**七、面向对象的三大特征**

- 封装：隐藏对象的属性和实现细节，仅公开对外接口，控制在程序中属性的读和修改的访问级别。其目的是增强安全性和简化编程，使用者无需了解具体的实现细节，通过外部接口就能使用类成员

- 继承：子类继承父类的特征和行为，使得子类具有父类的实例域和方法。即子类继承父类的方法

- 多态：一个对象的相同方法不同情况下有不同的表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。

  - 多态的优点：

    - 消除类型之间的耦合性
    - 可替换性
    - 可扩充性
    - 接口性
    - 灵活性
    - 简化性

  - 多态存在的必要条件：

    - 继承
    - 重写（子类继承父类后，对父类的方法重新定义）
    - 父类引用指向子类对象

    tips:总的来说，多态在继承的基础上形成

**七、C++虚函数**

​	谈到虚函数，必定会谈到多态

​	有如下几个问题：

- **类引入虚函数后，类会产生什么变化？**

  - 当在一个类中引入虚函数后，类的sizeof由1变为4(Windows)或者8(Linux)，会添加一个看不见的成员变量，即虚函数表指针（就是4个字节WIN，占用类对象的内存空间）。

- **虚函数表的生成时机和原因**

  - 当类中存在至少一个虚函数时，编译器就会为这个类创建一个虚函数表（virtual table），经过编译链接生成可执行文件之后，该类同其虚函数表都会保存在可执行文件里面，同样在执行时也会一起装载到内存中来。

- **虚函数表指针被赋值的时机**

  - 虚函数表指针与虚函数表的关系：对存在虚函数的类，编译器会自动在该类的构造函数安插为虚函数表指针的赋值语句（编译期间进行）。虚函数表指针指向虚函数表。

- **类对象在内存中的布局**

  - 以图中类为例

    ![](\JODE-HRK.github.io\assets\image\vitual_fun_example.jpg)

  - 类A对象的内存布局

    ![](\JODE-HRK.github.io\assets\image\vitual_fun_memstructure.jpg)

- 以上四个问题连贯起来，再继续深究虚函数的工作原理和多态的体现

  - 一般概念：父类有一个虚函数，子类有一个同名虚函数，当通过父类指针new一个子类对象或通过父类引用绑定一个子类对象时，如果用这个父类指针来调用这个虚函数，那么一定是使用的是子类的虚函数

  - 多态性（从两个方面来谈）

    - 代码实现上：

      - 调用虚函数的时候的调用路线：利用vptr(虚函数表指针)，找到vtbl(虚函数表)，再通过vtbl找到虚函数的入口地址，并执行该虚函数。（如果是这个路线，则是多态；否则不是）

      - 假设有一个Base类，其中有一个myvirfunc的虚函数

      - ```C++
        Base* pa = new Base();
        pa->myvirfunc();//是多态
        
        Base base;
        base.myfirfunc();//不是多态 
        
        Base* ybase = &base;
        ybase -> myvirfunc();//是多态
        ```

    - 表现形式上：

      - 程序中既要有子类，也要有父类，且父类中必须要有虚函数，子类必须重写虚函数
      - 父类指针指向子类对象 或 父类引用绑定子类对象
      - 当通过父类指针或引用，调用子类中重写的虚函数时，就能看出多态性的表现。（最终调用的是子类的虚函数）
      - 当子类对象只重写了父类的其中一个虚函数，其同样会有虚函数表指针，指向的虚函数表，除了被重写的虚函数地址不同，其他一样。

Tips:

- 一个空类的sizeof为1（至少是1）
- 析构函数可以是虚函数。
- 多态必须要有虚函数，没有虚函数，绝对不可能存在多态。
- 析构函数可以是虚函数。

**八、基类与派生类**

实际上就是父子类的相对关系，当存在两个类A和B，都需要写一个相同的Cal()函数时，不需要两个类都进行实现，只需要新建一个类C，在C中编写Cal()函数，A类和B类继承C类即可。

从这个方向来说，C是A和B的基类，而A和B是C的派生类

**九、构造函数**

- 无参数构造函数

- 有参数构造函数

- 拷贝构造函数

  - 用一个对象去初始化另一个对象

    ```
    tips:
    1、初始化和赋值的区别，赋值操作是在两个已经存在的对象间进行的，而初始化是要创建一个新的对象，并且其初值来源于另一个已经存在的对象
    2、拷贝构造函数生成新的类对象，而赋值运算符不能
    3、由于拷贝构造函数是直接一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。   而赋值运算符则需要这个操作，另外赋值运算中，如果原来的对象中有分配内存，则需要先把内存释放掉
    ```

    

- 默认构造函数

  - 无用构造函数：trival 平凡默认构造函数。函数无内容，纯粹是为了保证类能够正常运行，由编译器自动建立的
  - 有用构造函数：non-trival非平凡默认构造函数，只有在实际上被调用时才会生成此默认函数，例如：在一个类中定义另外两个类，那么，此类函数在被调用时，就需要自动生成能够生成另外两个类的构造函数

**十、类成员函数的重写、重载和隐藏区别**

- 重写和重载：
  - 范围的区别：被重写的和重写的函数在两个类中，而重载函数和被重载函数在同一个类中
  - 参数的区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一定不同