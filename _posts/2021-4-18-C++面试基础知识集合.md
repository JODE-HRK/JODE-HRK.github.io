---
title: C++面试基础知识集合
tags:
  - 面试
  - C++
---

# C++面试基础知识集合

**一、变量的声明和定义**

​	定义：为变量分配地址和存储空间

​	声明：不分配地址

​	一个变量可以在多个地方声明，但只在一个地方定义。

​	使用**extern**修饰的变量的声明，说明此变量在文件以外或在文件后面部分定义。

​	说明：很多时候一个变量，只是声明不分配内存空间，知道具体使用时才初始化，分配内存空间。如外部变量。

**二、sizeof和strlen的区别**

​	sizeof是一个操作符，strlen是库函数。

​	sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为 '\0' 的字符串做参数

​	编译器在编译时就计算出sizeof的结果，而strlen函数必须在运算时才能计算出来。sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串的实际长度。

**三、C++的关键字static有什么作用**

- 什么是static？
  - C++中很常用的的修饰符，用来控制变量和存储方式和可见性
- 为什么要引入static？
  - 函数内部定义的变量，在程序执行到其定义处会为其分配一个空间，而函数在栈上分配的空间在函数结束时会释放掉，那么就产生了一个问题：如果想将函数中此变量的值保存至下一次调用时，如何实现？最容易想到的方法就是定义一个全局变量，但定义一个**全局变量**有许多缺点，最明显的就是**破坏了此变量的访问范围**（使得在此函数中定义的该变量，不仅仅受此函数控制）。那么此时，我们就需要引入static
- 什么时候使用static？
  - 需要一个数据对象为整个类而非某一个对象服务，同时有**力求不破坏类的封装性**。即要求此成员隐藏在类的内部，对外不可见。
- static的内部机制：
  - 静态数据成员要在程序一开始就必须存在。因为函数在程序运行中被调用，所以静态数据成员不能在任何函数内分配空间和初始化。
  - 静态数据成员的空间分配由三个可能的地方，一是作为类的外部接口的头文件，此处由类声明；二是类定义的内部实现，那里有类的成员函数定义；三是全局数据声明和定义处。
  - tips:由于静态数据成员要实际的分配空间，故不能在类的声明处定义（只能声明数据成员）。类声明只声明一个类的尺寸和规格，并不进行实际的内存分配。也不能在头文件中类声明的外部定义，因为会造成在多个使用该类的源文件中对其重复定义。
  - static被引入后告知编译器，将变量存储在程序的静态存储区而非栈上空间，静态数据成员按照定义时的顺序一次初始化。
- static的优势：
  - 节省内存，其对所有对象共有，因此，对多个对象来说，静态数据只存在在于一处，供所有对象使用。静态数据成员的值对每一个对象都一样，而且它的值时可以更新的，每一次更新后，其后所有调用的对象都是使用的新值，这样可以提高时间效率。
  - static没有增加程序的时空开销，相反其还缩短了子类对父类静态成员的访问时间，节省了子类的内存空间。
- static的局限性：
  - 类的静态成员函数是整个类而非类的对象，所以其没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数
  - 无法将静态成员函数定义为虚函数
  - 因为静态成员函数声明于类中，操作于其外，所以对静态成员函数取地址就稍显特殊，变量地址是指向其数据类型的指针，函数地址类型是一个“nonmember函数指针。”

**四、volatile（易变的）关键字**

​	volatile关键字和const关键字对应，volatile表示类型变量表示被某些编译器更改。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。（优化：两次读取之间没有发向对变量的修改，那么就会直接使用上次读的数据）也就是说，使用volatile修饰的变量，每次使用的时候都会再一次直接从其地址读取数据，避免了一些特殊情况下的出错。

由此可知volatile关键字一需要使用的几种情况：

- 中断服务程序中修改的供其他程序检测的变量
- 多任务环境中各任务之间共享的标志变量（多线程）
- 存储器映射的硬件寄存器通常也需要使用volatile，因为每次读写都可能有不同意义

**五、C++程序编译的内存分配情况**

​	内存分配方式一般可分为三种

- 从静态存储区域分配：
  - 内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。
  - 优点：速度快、不易出错，因为由系统会善后。例如全局变量，static变量等
- 从栈上分配：
  - 在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时，这些存储单元自动释放。
  - 优点：栈内存分配算法内置于处理器的指令集中，效率高
  - 缺陷：分配的内存容量有限。
- 从堆上分配：
  - 即动态内存分配。程序在运行的时候使用malloc或new申请任意大小的内存，由程序员自己负责在何时使用free或delete释放内存。动态内存的生存期由程序员决定，使用灵活。如果堆上分配了空间，就有责任回收它，否则程序会出现内存泄漏，此外，频繁的分配和释放不同大小的堆空间将会产生堆内碎块。

Tips：

- C++程序编译时，内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区
- 程序的局部变量存在于栈中，全局变量存在于静态存储区，动态申请数据存在于堆中。

**六、strcpy、sprintf与memcpy的区别**

- 操作对象不同，strcpy的两个操作对象均为字符串，sprintf的操作对象可以是多种数据类型
- 执行效率不同，memcpy最高，strcpy次之，sprintf最低
- 实现功能不同，strcpy主要实现字符串变量间的拷贝，sprintf主要实现其他数据类型到字符串类型的转换，memcpy主要是内存块之间的拷贝。

Tips：strcpy、sprintf与memcpy都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能

**七、面向对象的三大特征**