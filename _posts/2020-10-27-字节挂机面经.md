---
title: 2020年字节第二次面试挂机
tags:
  - 面经
  - 字节跳动
  - JAVA
  - 计算机组成原理
---

## 这次是真的内心奔溃！！！！！

相比上一次面试，这次是真的实实在在感受到了自己的失败。。。先来回顾一遍

面试官一开始上来就给我道数据结构题。。。给我先序遍历、中序遍历，让我把这颗树构造出来。。。。明明是道很简单的题（而且上数据结构的时候应该也写过），然后。。。我忘了。。。。而且思路已经有了。。但是到最后，一个递归都没写完。。。。。

思路：从先序遍历中一次找出**每颗子树的根**，根据中序遍历将每一段分成左子树和右子树两块，然后每一块进行递归即可。

下面给出正解代码：

```c++
/*
 * @Descripttion: 
 * @version: 
 * @Author: JODEHRK
 * @Date: 2020-10-28 10:13:02
 * @LastEditors: JODEHRK
 * @LastEditTime: 2020-10-28 10:22:26
 * 给定先序遍历和中序遍历，构造原来的树
 */
#include <bits/stdc++.h>
using namespace std;

int preorder[5] = {3, 9, 20, 15, 7};
int inorder[5] = {9, 3, 15, 20, 7};
int rootcnt = 0;
int len = 4;
int lel;
int tree[101];
void dfs(int id, int l, int r)
{
    lel = max(lel, id);
    int root = preorder[rootcnt];
    tree[id] = preorder[rootcnt];
    ++rootcnt;
    if (l == r)
        return;
    int mid;
    for (int i = l; i <= r; i++)
        if (inorder[i] == tree[id])
        {
            mid = i;
            break;
        }
    dfs(id << 1, l, mid - 1);
    dfs(id << 1 | 1, mid + 1, r);
}
int main()
{
    dfs(1, 0, 4);
    for (int i = 1; i <= lel; i++)
        printf("%d ", tree[i]);
    return 0;
}
```



第二题，给出一个字符串数组，让你找出长度最长的，而且是由其他字符串组成的字符串，如果有则找出字典序最小的那一个。
这个很简单，使用一颗字典树即可，标记每个节点是否为一个单词的结尾，并记下每个字符串的结尾。在寻找对应的字符串的时候，不断跳回根节点即可，这里使用递归。

因为这题我是直接写出来的，所以就不再放上代码反省。



## 最最头大的时刻到了！！！！

首先，面试官问我TCP和UDP区别，这是常规题，我也记得那么一些。。。但是当我听到这题时，马上就意识到情况不对，这些都是我最头大的概念问题啊啊啊啊啊！！！

果然，接下来的问题扯到了。。数据库、计算机组成原理、JAVA关键字。。。。

### 计算机组成原理：

*        **进程与线程：**

​		进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。

​		线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。

​		一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。

​		线程没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，线程文本包含在他的进程的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。

​		父和子进程使用进程间通信机制，同一进程的线程通过读取和写入数据到进程变量来通信

​		进程内的任何线程都被看做是同位体，且处于相同的级别。不管是哪个线程创建了哪一个线程，进程内的任何线程都可以销毁、挂起、恢复和更改其它线程的优先权。线程也要对进程施加控制，进程中任何线程都可以通过销毁主线程来销毁进程，销毁主线程将导致该进程的销毁，对主线程的修改可能影响所有的线程。

​		子进程不对任何其他子进程施加控制，进程的线程可以对同一进程的其它线程施加控制。子进程不能对父进程施加控制，进程中所有线程都可以对主线程施加控制。

- **Java在编译时内存是如何工作的：**

  这里我就直接扩展一下将相关内容全部写进来了：

  - 先理解几个概念：

    - 编译期：指把你的源程序交给编译器编译的过程，最终目的是得到可执行的文件。编译期确切地说应该是得到obj文件的过程，得到最后可执行文件的过程叫链接
    - 运行期：指的是你将可执行文件交给操作系统执行、直到程序执行结束的期间，执行的目的是为了实现程序的功能。

    编译期先于运行期，因为要先得到可执行文件，才能交给操作系统执行。

    - 编译时：正在编译的时候，即编译器将源代码翻译成机器能够识别的代码，或者其他的中间语言（如Java中有jvm识别的字节码，C#中有CLR能识别的MSIL，这些东西我们都统称为编译器）
    - 运行时：即代码在机器上运行起来了，已经被装载到内存中去了。
      - **好，到重点了，这里就是面试官问我的，java中编译时内存中是如何进行分配的：**
        - 讲实话，说到这里我都懵了，我学java的时候有学到这些东西吗？？？估计是面试官看我之前表现不怎么样，然后就打算这样把我给挂了算了。。。。
        - 不过。。知识点还是得挂上来：

关于java的内存分配：

- 一般来说，程序运行时的内存分配有三种策略：静态、栈、堆。
  - 静态存储分配：在编译时就能确定每个数据目标在运行时刻的存储空间需求，因而在编译时就可以给他们分配固定的内存空间。这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在，也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求。
  - 栈式存储分配：可称为动态存储分配，是由一个类似于堆栈的运行栈来实现的。和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的，只有到运行的时候才能够知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区大小才能够为其分配内存。和我们在数据结构所熟知的栈一样，栈式存储分配按照先进后出的原则进行分配。 
  - 堆式存储分配：静态要求**在编译时**能知道**所有变量**的存储要求，栈式存储分配要求**在过程的入口处**必须知道**所有变量**的存储要求，而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。
- 直接来比较下堆栈：
  - 从功能和作用上来做通俗的比较，堆主要用来存放对象的，栈主要是用来执行程序的。两者的区别主要是由于堆和栈的特点决定的: 
    - 栈：在C/C++程序中，所有函数的调用都是使用栈来实现的，其中所有的局部变量，形式参数都是从栈中分配内存空间的。实际上也不是所有东西全部分配，只是从栈顶向上用就行，就好像工厂中的传送带一样，栈指针会告知你到放东西的位置。你仅仅需要将栈上的东西取出来使用就行。在退出函数的时候，修改栈指针就可以把栈中的内容销毁。这样的模式速度最快，理所当然用来运行程序。需要注意的是，在分配的时候，比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小，即**虽然分配是在程序运行时进行的，但是分配的空间大小多少是确定的，不变的，而这个“大小多少”是在编译时确定的，不是在运行时**.。
    - 堆：堆是应用程序在运行的时候请求操作系统分配给自己内存，由于是从操作系统管理的内存分配，所以在分配和销毁时都要占用时间，因此用**堆的效率非常低**.但是堆的优点在于，编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆**保存数据时会得到更大的灵活性**。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定。在C/C++中，要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间！这也正是导致我们刚才所说的效率低的原因。
- 下面来认识下**JVM中的堆和栈**：
  - JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈。对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈**以帧为单位保存线程的状态**。JVM对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。 
  - 某个线程正在执行的方法称为此线程的当前方法，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数，局部变量，中间计算过程和其他数据。帧的概念和编译原理中的活动记录的概念有些相似。
  - 从java的分配机制来看：堆栈是操作系统在建立某个进程时或者线程（**在支持多线程的操作系统中是线程**）为这个线程建立的存储区域，该区域具有先进后出的特性。 
  - 每一个JAVA应用都对应着一个JVM实例，而每一个实例又对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中，并由应用所有的线程共享。跟C/C++不一样，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配，即在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。
- 往上走，认识下JAVA的堆和栈：
  - JAVA把内存分为两种：栈内存和堆内存。
  - 在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以马上另作他用。 
  - 堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 
  - 栈与堆都是Java用来在RAM内存中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。
  - 对比：
    - Java的堆是一个运行时数据区，类的对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 
    - 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。 其次，栈还有一个极为重要的特性，即栈中的数据能够共享。
      - 举个栗子：
        - 当int x = 7时，编译器会查询栈中是否有7这个值，此时没有，就将7压入栈中，并将x的指针指向存7的地址，之后又遇到int y = 7; 此时会查询7是否在栈中，此时存在，直接将y的指针指向7，x、y的指针均指向同一个地址。当我们在修改x的时候，不会引起y的指针修改。
        - 分析：这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况x的修改并不会影响到y, 它是由编译器完成的，它**有利于节省空间**。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。

### JAVA关键字：

```java
threadlocal 是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据.ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。
is:判断子类是否为一个父类的继承
has:判断该类是否为这个类的组成部分。
```

关于threadlocal可以观摩一下这篇巨佬的博客https://www.jianshu.com/p/3c5d7f09dfbd

