---
title: 洛谷 2020 ACM春季多校 第三场
tags:
  - C++
  - ACM
  - 算法竞赛
  - 二分

---

## 洛谷 2020 ACM春季多校 第三场

目录：AB、二分或者遍历	CD、二分	EFGH

A、Able was I ere I saw Elba

B、Bit fixer

题意：给你一个二进制串，每一次对方都会反转一个位置上的数字（0变1，1变0），同时你也可以**至多**跟着反转任意位置上的数字一次，问你最少在第几次的时候，能够变成目标串。

分析：一步步扫过去，判断还有多少个是不同位置，当与第i次反转等于i或i-1的时候，就是达到目标的时候了。其实一开始的二分答案也可以，其单调性很显然check判断天数即可，是我读题有漏洞才拖延了。

教训：这题出的慢有我读题的锅，MD又没读清楚。还有，自己写程序的时候。。忘记把位置更改了，每一次转换必须要更改位置上的数字，保证后面的再更改有效。

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 7;
int n, t, rel[maxn];
string a, b;
int main()
{
    //   freopen(".in","r",stdin);
    scanf("%d %d", &n, &t);
    cin >> a;
    cin >> b;
    reverse(a.begin(), a.end());
    reverse(b.begin(), b.end());
    int sum = 0;
    for (int i = 0; i < n; i++)
        if (a[i] != b[i])
            sum++; //表示相同的位置不同符号
    if (sum == 0)
    {
        cout << sum;
        return 0;
    }
    for (int i = 1; i <= t; i++)
    {
        scanf("%d", &rel[i]);
        if (a[rel[i]] != b[rel[i]])       //第i次反转的是不同的地方
            sum--, a[rel[i]] = b[rel[i]]; //
        else
            sum++, a[rel[i]] = !b[rel[i]];
        if (i == sum || i == sum + 1)
        {
            cout << i;
            return 0;
        }
    }
    printf("icu\n");
    return 0;
}
```



C、Coprime

D、Dodo bird painting

题意：在线段上有q个点，第i个点上都有墨水以v[ i ] 的速度向两边蔓延，求最少在什么时间的时候墨水将线段全部覆盖。

分析：仔细想想就有点像求最长时间最短的问题，但是由于该题是卡精度的，所以采用小数二分。二分就不说了，讲讲check，我自己写的时候，没有考虑完全，我只是讲每两个点之间的一段判断是否会被覆盖完全，忽略了每个点的蔓延速度的不一样，需要将每一段的在该时间里面的覆盖全部求出来，然后依次判断是否完全覆盖线段。

教训：格局观小了，要整体判断。

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 7;
int n, q;
struct Drop
{
    double x, v;
} drop[maxn];
pair<double, double> lp[maxn];
bool cmp(Drop x, Drop y)
{
    return x.x < y.x;
}
double r = 1e9, l = 0e0;
bool cmp2(pair<double, double> X, pair<double, double> Y)
{
    return fabs(X.first - Y.first) < 1e-6 ? X.second < Y.second : X.first < Y.first;
}
bool check(double ans)
{
    double p = 1e9, maxx = 0;
    for (int i = 1; i <= q; i++)
        lp[i] = {drop[i].x - drop[i].v * ans, drop[i].x + drop[i].v * ans};
    sort(lp + 1, lp + 1 + q, cmp2);
    lp[0] = {0, 0}, lp[q + 1] = {n, n};
    for (int i = 1; i <= q; i++)
    {
        if (lp[i].first > maxx)
            return 0;
        maxx = max(maxx, lp[i].second);
        p = min(p, lp[i].first);
    }
    if (p > 0 || maxx < n)
        return 0;
    return 1;
}
int main()
{
    scanf("%d %d", &n, &q);
    drop[0] = {0.0, 0.0}, drop[q + 1] = {n * 1.0, 0.0};
    for (int i = 1; i <= q; i++)
        scanf("%lf %lf", &drop[i].x, &drop[i].v);
    sort(drop + 1, drop + 1 + q, cmp);
    double time = 0.0;
    while (fabs(r - l) >= 0.00000001)
    {
        double mid = (l + r) / 2;
        if (check(mid))
            r = mid, time = mid;
        else
            l = mid + 0.00000001;
    }
    printf("%.7lf", time);
    return 0;
}
```



E、Eluos blocks

F、Fake information

G、Game

H、Huaji robot

