---
title: 洛谷 2020 ACM春季多校 第二场
tags:
  - 未完成
  - C++
  - ACM
  - 算法竞赛

---

## 洛谷 2020 ACM春季多校 第二场

目录：A. 拓扑排序

A. Misaka Network

​	题意：给你n个点的DAG（有向无环）图，让你从中选择点，与被选择的点相连的点被称为被控制点，要求你选择最少的点，使得整个图都被控制。（选择的点不能相连） tips：acyclic无环的。。。赛场上没看懂这个单词的意思

​	分析：赛场上，第一感觉是贪心。。然后题解给的是拓扑排序（可是为什么我做出来是错的？）。

​	教训：看题NMD，**acyclic无环的**，我TM不认识这个单词

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 7;
int n, m, in[maxn], out[maxn], id[maxn];
bool vis[maxn];
vector<int> edge[maxn];
void add(int x, int y)
{
    edge[x].push_back(y);
}
bool cmp(int x, int y)
{
    if (in[x] == in[y])
        return out[x] > out[y];
    return in[x] < in[y];
}
queue<int> Q;
queue<int> S;
int ans = 0;
int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        out[u]++, in[v]++;
        add(u, v);
    }
    int ans = 0;
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= n; i++)
        if (!in[i])
            Q.push(i);
    while (!Q.empty())
    {
        int now = Q.front();
        S.push(now);
        Q.pop();
        for (auto v : edge[now])
            if (--in[v] == 0)//注意这个地方，拓扑排序一定要是这个，不然会炸
                Q.push(v);
    }
    while (!S.empty())
    {
        int now = S.front();
        S.pop();
        if (!vis[now])
            ans++, vis[now] = 1;
        else
            continue;
        for (auto v : edge[now])
            vis[v] = 1;
    }
    printf("%d", ans);
    return 0;
}
```



B. Mana Eel’s Problem 

题意：给你一个长度为n的序列和一个整数x，你要回答q个问题。每个问题包含两个整数 l 和 r，你需要计算如下公式：
$$
\prod_{i=l}^r
(µ(a_i ) + a_i + x) mod 998244353
$$
其中，
$$
µ(x)=\left\{
\begin{aligned}
& 1, \ \ if (n=1)\\ 
& (-1)^k ,if(n=\prod_{i=1}^kp_i(p_1 ,p_2 ,...,p_k
are \ distinct \ prime \ numbers))\\
& 0 , \ \  others
\end{aligned}
\right.
$$


分析：又到了数论挖坑的时间，先上标程代码

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int> pii;
#define read(a) scanf("%d", &a)
#define N 303333
namespace P_R {
	void mul(LL &x, LL y, LL m) {
		x %= m, y %= m;
		unsigned long long t = (long long)((long double)x * y / m);
		x = (unsigned long long) x * y - t * m;
		x = (x % m + m) % m;
	}

	LL power(LL x, LL y, LL m) {
		LL ret = 1;
		for (x %= m; y; y >>= 1) {
			if (y & 1) mul(ret, x, m);
			mul(x, x, m);
		}
		return ret;
	}

	LL Rand() {
		static LL a = 2333333;
		a ^= a >> 12;
		a ^= a << 25;
		a ^= a >> 27;
		return a * 0x2545F4914F6CDD1D;
	}

	LL gcd(LL a, LL b) {
		while (b) {
			LL c = a;
			a = b; b = c % b;
		}
		return a;
	}

	const int P[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, -1}; // 3.8e18
	// 1e9 : 2, 7, 61
	// 1e12 : 2, 13, 23, 1662803
	// ULL : ~37
	vector<LL> D;

	bool witness(int p, LL x, int t, LL n) {
		LL y = power(p, x, n);
		if (y == 1) return 0;
		for (int i = 0; i < t; i++) {
			if (y == n - 1) return 0;
			if (y == 1) return 0;
			mul(y, y, n);
		}
		return 1;
	}

	bool MR(LL n) { // O(k log ^ 3)
		if (n < 4) return 1;
		for (int i = 0; ~P[i]; i++) {
			if (n == P[i]) return 1;
			if (n % P[i] == 0) return 0;
		}
		LL x = n - 1; int t = 0;
		while (~x & 1) {
			++t;
			x >>= 1;
		}
		for (int i = 0; ~P[i]; i++) {
			if (witness(P[i], x, t, n)) return 0;
		}
		return 1;
	}

	void PR(LL n) { // O(n ^ {1 / 4} * log)
		if (MR(n)) {
			D.push_back(n);
			return;
		}
		LL a, b, c, d;
		while (1) {
			c = Rand() % n;
			a = b = Rand() % n;
			mul(b, b, n); (b += c) %= n;
			while (a != b) {
				d = a > b ? a - b : b - a;
				d = gcd(d, n);
				if (d > 1 && d < n) {
					PR(d); PR(n / d);
					return;
				}
				mul(a, a, n); (a += c) %= n;
				mul(b, b, n); (b += c) %= n;
				mul(b, b, n); (b += c) %= n;
			}
		}
	}
	vector <LL> solve(LL n) {
		D.clear();
		if (n < 2) return D;
		PR(n);
		sort(D.begin(), D.end());
		return D;
	}
}

LL b[N];
// segtree.cpp @ fstqwq/CodeForcesTemplate
template <class V> class Tree {
	struct Node {
		int l, r;
		V v;
	} t[N * 2] ;
	int tcnt, L, R;
	int build(int l, int r) {
		int x = ++tcnt;
		if (l < r) {
			int mid = (l + r) / 2;
			t[x].l = build(l, mid);
			t[x].r = build(mid + 1, r);
			t[x].v = t[t[x].l].v + t[t[x].r].v;
		}
		else {
			t[x].l = t[x].r = 0;
			t[x].v = b[l]% 998244353;
		}
		return x;
	}
	V qry(int x, int l, int r, int ql, int qr) {
		if (l == ql && r == qr) return t[x].v;
		int mid = (l + r) / 2;
		if (qr <= mid) return qry(t[x].l, l, mid, ql, qr);
		if (ql >  mid) return qry(t[x].r, mid + 1, r, ql, qr);
		return qry(t[x].l, l, mid, ql, mid) + qry(t[x].r, mid + 1, r, mid + 1, qr);
	}
public:
	Tree () {}
	void init(int l, int r) {
		L = l, R = r;
		tcnt = 0;
		build(l, r);
	}
	inline V qry(int l, int r) {return qry(1, L, R, l, r);}
};


struct V {
	LL x;
	V () {}
	V (LL y) {x = y;}
	friend V operator + (const V &c, const V &d) {
		return V(c.x * d.x % 998244353);
	}
};

Tree <V> t; 

int n, Q, X;
LL a[N];
vector <LL> pr;

void insert(LL x) {
	for (auto v : pr) {
		if (v == x) return;
	}
	pr.push_back(x);
}

int main() {
	read(n); read(Q); read(X);
	for (int i = 1; i <= n; i++) scanf("%lld", a + i);
	for (int i = 1; i <= n; i++) {
		LL c = a[i];
		vector <LL> d;
		for (auto v: pr) {
			while (c % v == 0) {
				c /= v;
				d.push_back(v);
			}
		}
		auto vv = P_R::solve(c);
		for (auto v : vv) d.push_back(v);
		sort(d.begin(), d.end());
		LL ret = 0;
		if (unique(d.begin(), d.end()) != d.end()) ret = 0;
		else ret = d.size() & 1 ? -1 : 1;
		ret += a[i] + X;
		ret %= 998244353;
		b[i] = ret;
		for (auto v : d) {
			insert(v);
		}
	}
	t.init(1, n);
	for (int i = 1; i <= Q; i++) {
		int l, r;
		read(l); read(r);
		printf("%d\n", int(t.qry(l, r).x));
	}
}
```



C. Schedule

​	题意：按时间进行课程查询

​	分析：中模拟

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e4 + 6;
int n, cnt = 0, m, p = 0, y;
string str[maxn];
string st;
vector<int> stMonth[maxn], endMonth[maxn];
vector<int> week[maxn];
vector<int> stClass[maxn], endClass[maxn];
bool lesson[13];
struct Ans
{
    int sta, ed;
    string name;
};
vector<Ans> ans;
int getsum(int &sst)
{
    int sum = 0;
    for (int i = sst; i < st.length(); i++)
    {
        if (st[i] < '0' || st[i] > '9')
        {
            sst = i + 1;
            return sum;
        }
        sum = sum * 10 + st[i] - '0';
    }
    return sum;
}
int getweek(int sst)
{
    for (int i = sst; i < st.length(); i++)
    {
        if (st[i] == 'M')
            return 1;
        if (st[i] == 'W')
            return 3;
        if (st[i] == 'F')
            return 5;
        if (st[i] == 'u')
            return 2;
        if (st[i] == 'h')
            return 4;
    }
    return 0;
}
bool cmp(Ans x, Ans y)
{
    return x.sta < y.sta;
}
int main()
{
    // freopen(".in", "r", stdin);
    // freopen(".out", "w", stdout);
    scanf("%d", &n);
    cin.get();
    while (getline(cin, st))
    {
        if ((st[0] >= 'A' && st[0] <= 'Z') || (st[0] >= 'a' && st[0] <= 'z'))
        {
            str[++cnt] = st;
            p = 1;
            str[cnt].erase(str[cnt].end() - 1);
        }
        else
        {
            if (st.find("-") == st.npos)
                break;
            y = 0;
            stMonth[cnt].push_back(getsum(y));
            endMonth[cnt].push_back(getsum(y));
            week[cnt].push_back(getweek(y));
            y += 4;
            stClass[cnt].push_back(getsum(y));
            endClass[cnt].push_back(getsum(y));
            p = 0;
        }
    }

    // for (int i = 1; i <= cnt; i++)
    // {
    // 	cout << str[i] << endl;
    // 	int len = stMonth[i].size();
    // 	for (int j = 0; j < len; j++)
    // 	{
    // 		printf("%d %d %d %d %d\n", stMonth[i][j], endMonth[i][j], week[i][j], stClass[i][j], endClass[i][j]);
    // 	}
    // 	cout << endl;
    // }
    // cout << endl
    // 	 << endl
    // 	 << endl;
    int now = 0;
    m = getsum(now);
    while (m--)
    {
        ans.clear();
        int month, weekday;
        scanf("%d", &month);
        cin >> st;
        weekday = getweek(0);
        for (int i = 1; i <= cnt; i++)
        {
            int len = stMonth[i].size();
            for (int j = 0; j < len; j++)
            {
                if (stMonth[i][j] <= month && month <= endMonth[i][j] && week[i][j] == weekday)
                {
                    ans.push_back({stClass[i][j], endClass[i][j], str[i]});
                }
            }
        }
        sort(ans.begin(), ans.end(), cmp);
        for (int i = 0; i < ans.size(); i++)
        {
            printf("%d-%d ", ans[i].sta, ans[i].ed);
            cout << ans[i].name;
            cout << endl;
        }
        cout << endl;
    }
    return 0;
}
```



D. Voluntary Hotel

题意：给你n个点的简单图，每个点标号为1~n。有p个医院和r个医生分布在一些点上。有q个旅馆给医生提供，如果医生选择住在旅馆，那么他每天就会从旅馆出发去他们呢在岗的医院。第i个旅馆最多能住hi个医生.现在你来为医生们安排，使得住得离自己医院最远的医生离自己医院的距离最近。

分析：典型的需要二分处理（最长的距离最短），接下来就要想如何check了，题解说用网络流（坑留下）。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int, int> pii;
#define read(a) scanf("%d", &a)
#define x first
#define y second


const LL INF = 1e18;
const int N = 405;
const int E4 = 1e4 + 5;
const int E6 = 1e6 + 5;

namespace Flow {
	struct edge {
		int next,to,flow;
	}e[N * N];
	int n, S, T;
	int ecnt,head[N],cur[N],tag[N];

	void init(int nn, int ss, int tt) {
		ecnt=1;
		n = nn, S = ss, T = tt;
		for (int i = 1; i <= n; i++) head[i] = 0;
	}

	void add(int u,int v, int w) {
		e[++ecnt].to=v;
		e[ecnt].next=head[u];
		e[ecnt].flow=w;
		head[u]=ecnt;
		e[++ecnt].to=u;
		e[ecnt].next=head[v];
		e[ecnt].flow=0;
		head[v]=ecnt;
	}

	queue <int> q;
	bool bfs() {
		for (int i = 1; i <= n; i++) tag[i] = 0;
		while (!q.empty()) q.pop();
		q.push(S);
		tag[S]=1;
		while (!q.empty()) {
			int x=q.front();q.pop();
			for (int now=head[x];now;now=e[now].next) {
				if (e[now].flow && !tag[e[now].to]) {
					tag[e[now].to]=tag[x]+1;
					q.push(e[now].to);
				}
			}
		}
		return tag[T] > 0;
	}

	int dfs(int x,int flow) {
		if (x==T) return flow;
		int usd=0;
		for (int &now=cur[x];now;now=e[now].next) {
			if (e[now].flow && tag[x] + 1 == tag[e[now].to]) {
				int ret = dfs(e[now].to, min(e[now].flow, flow - usd));
				if (ret) {
					usd += ret;
					e[now].flow -= ret;
					e[now^1].flow += ret;
					if (usd==flow) return flow;
				}
			}
		}
		return usd;
	}

	int solve() {
		int ans=0;
		while (bfs()) {
			for (int i = 1; i <= n; i++) cur[i] = head[i];
			ans += dfs(S, 0x3f3f3f3f);
		}
		return ans;
	}
}


struct Edge {
	int v, w;
};
vector <Edge> E[E4];

void add(int u, int v, int w) {
	E[u].push_back({v, w});
	E[v].push_back({u, w});
}


int n, m, P, Q, R;
priority_queue < pair<LL, int> > q;
void dij(int s, LL dis[]) {
	for (int i = 1; i <= n; i++) dis[i] = INF;
	dis[s] = 0;
	q.push({0, s});
	while (!q.empty()) {
		auto o = q.top(); q.pop();
		LL d = -o.first; int x = o.second;
		if (dis[x] != d) continue;
		for (auto v : E[x]) {
			if (dis[v.v] > d + v.w) {
				dis[v.v] = d + v.w;
				q.push({-dis[v.v], v.v});
			}
		}
	}
}

LL dis[N][E4];

int X[N], Y[N], H[N];
int S[E6], K[E6];
LL dd[E6];
int cnt[N];

bool check(LL md) {
	for (int i = 1; i <= P; i++) cnt[i] = 0;
	int tot = 0;
	for (int i = 1; i <= R; i++) {
		if (dd[i] > md) cnt[K[i]]++, tot++;
	}
	Flow::init(P + Q + 2, 1, P + Q + 2);
	for (int i = 1; i <= P; i++) if (cnt[i]) {
		Flow::add(1, i + 1, cnt[i]);
		for (int j = 1; j <= Q; j++) if (dis[i][Y[j]] <= md){
			Flow::add(i + 1, 1 + P + j, 0x3f3f3f3f);
		}
	}
	for (int i = 1; i <= Q; i++) {
		Flow::add(1 + P + i, P + Q + 2, H[i]);
	}
	return Flow::solve() == tot;
}

int main() {
	read(n); read(m); read(P); read(Q); read(R);
	for (int i = 1; i <= m; i++) {
		int u, v, w;
		read(u); read(v); read(w);
		add(u, v, w);
	}
	for (int i = 1; i <= P; i++) {
		read(X[i]);
		dij(X[i], dis[i]);
	}
	for (int i = 1; i <= Q; i++) {
		read(Y[i]); read(H[i]);
	}
	for (int i = 1; i <= R; i++) {
		read(S[i]); read(K[i]);
		dd[i] = dis[K[i]][S[i]];
	}
	LL l = 0, r = LL(1e9 * n);
	while (l < r) {
		LL md = (l + r) / 2;
		if (check(md)) r = md;
		else l = md + 1;
	}
	printf("%lld\n", l);
}
```

E. Anan and Minecraft

题意：

分析：

```c++

```



F. Rebuild Teldrassil

G. Fetch spring water

H. Mana Eel’s Graph