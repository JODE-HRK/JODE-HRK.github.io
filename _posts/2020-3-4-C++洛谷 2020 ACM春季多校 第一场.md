---
title: 洛谷 2020 ACM春季多校	第一场
tags:
  - C++
  - ACM
  - 算法竞赛
  - 洛谷
  - 最短路

---

## 洛谷 2020 ACM春季多校	第一场

A.	À la Volonté du Peuple

​	**题目大意：**给你一张图，从起点1号点开始点火，或会按照一定速度传播，当两个火或多个火烧到一起的时候，会产生爆炸。现在给你一张图，问这张图里面会发生多少次爆炸。

​	**分析：**首先，按照火烧的方式，火到点的距离，一定是按照最短路进行的，所以我们首先需要求从1号点开始的单源最短路。在点上爆炸的次数，就是遍历每个点是否有多个火源同时到达这个点即可。那么，在路径上面的爆炸怎么记录呢？很显然，爆炸在点上面的是特殊情况，产生爆炸的时候，火走的距离一定是相等的。所以，如果判断两个点之间是否有一个相等的中点就好了。

​		**本题经验：vis数组一定要初始化，下次存边使用前向星，这个代码有一个点无论如何都过不了，都是TLE，以后都用前向星！！**

上垃圾代码：

```c
#pragma GCC optimize(2)
#include <bits/stdc++.h>
using namespace std;
const int maxn = 3e5 + 7;
int n, m, dis[maxn];
struct Edge
{
    int to, w;
};
vector<Edge> edge[maxn];
void dij()
{
    bool vis[maxn];
    for (int i = 1; i <= n; i++)
        dis[i] = 0x7fffffff, vis[i] = 0;
    dis[1] = 0;
    queue<int> Q;
    Q.push(1);
    while (!Q.empty())
    {
        int nownode = Q.front();
        Q.pop();
        vis[nownode] = 0;
        for (int i = 0; i < edge[nownode].size(); i++)
        {
            int tto = edge[nownode][i].to, ww = edge[nownode][i].w;
            if (dis[tto] > dis[nownode] + ww)
            {
                dis[tto] = dis[nownode] + ww;
                if (!vis[tto])
                    Q.push(tto), vis[tto] = 1;
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); //这两段加速C++输入输出流
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        edge[a].push_back({b, c});
        if (a != b)
            edge[b].push_back({a, c});
    }
    dij();
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        int p = 0;
        for (int j = 0; j < edge[i].size(); j++)
        {
            int tto = edge[i][j].to, ww = edge[i][j].w;
            if (dis[tto] + ww == dis[i])
                p++;
            else if (i >= tto && dis[i] + ww > dis[tto] && dis[tto] + ww > dis[i])
                ans++;// i >= tto 确保同一条边只算一次
        }
        if (p > 1)
            ans++;//在点上只可能爆炸一次
    }
    cout<<ans;
    return 0;
}
```

B.	Billionaire

**题目大意：**给你当前的钱数，然后以当前天为第0天开始，第i天给你i元。再给你个当前日期，问什么时候你会超过1e9元。

**分析：**1e9的额度，肯定得用二分法得出天数，然后按照年月进行跳跃计算。出题者说用zeller公式，既然是套公式，我们就直接上代码。

```c++
#include <bits/stdc++.h>
using namespace std;
int getId(int y, int m, int d) {
	if (m < 3) {y --; m += 12;}
	return 365 * y + y / 4 - y / 100 + y / 400 + (153 * (m - 3) + 2) / 5 + d - 307;
}
vector<int> date(int id) {
	int x = id + 1789995, n, i, j, y, m, d;
	n = 4 * x / 146097;
	x -= (146097 * n + 3) / 4;
	i = (4000 * (x + 1)) / 1461001; x -= 1461 * i / 4 - 31;
	j = 80 * x / 2447; d = x - 2447 * j / 80; x = j / 11;
	m = j + 2 - 12 * x; y = 100 * (n - 49) + i + x;
	return vector<int>({y, m, d});
}
void work() {
	int M, y, m, d;
	scanf("%d%d%d%d", &M, &y, &m, &d);
	int id = getId(y, m, d);//年月日
	int l = 0, r = sqrt(2e9);
	while (l < r) {
		int mid = (l + r) / 2;
		int v = M + (0 + mid) * (mid + 1) / 2; 
		if (v >= 1000000000) r = mid;
		else l = mid + 1;
	}//二分法得出要过去的天数
	id += l;
	auto ret = date(id);//这个vector的用法好帅！
	printf("%d %d %d\n", ret[0], ret[1], ret[2]);
}

int main() {
	int T;
	scanf("%d", &T);
	while (T--) work();
}
```

C、Counting K-ary Palindromes

**题目大意：**输入n、p、k，要你求在k进制下，长度为n的，可以被质数p整除的数有多少个。注意，n<=1e8，2<=p<1000，2<=k<=16，并且答案最后要 % 998244353

**分析：**这道题。。费马大定理+循环节+快速幂。。。对于数论。。我先留个坑

D、Deceiver

**题目大意：**对于公式 Ax + By = C， 保证A、B互质，且均 [1 , 1e7]，请你求不满足该公式的第 k 小的数， k 为[1 , 1e18].

**分析：**类欧几里得 + 二分 。。。数论：留坑

F、Final Spark

**题目大意：**拉克丝在距离提莫d的地方，对着提莫放大招，光束无限长，宽度为w，提莫在拉克丝放出大招的时候，会随机像一个方向移动s的直线距离，而提莫可以视为是一个直径为r的圆，问假设拉克丝以最优的方式放大招，能打到提莫的最大概率为多少？（原题是半径，出题人的锅，提莫的r是直径）

**分析：**这题肯定得画图

​	![1581826760296](\JODE-HRK.github.io\assets\image\洛谷 春季多校 Final Spark1.png)

上图中，黑圈为提莫原来的位置，红圈为提莫移动后圆心可能在的位置，蓝圈为移动后	提莫体积能达到的最远位置

可以分析得出，要想以最大概率打到提莫，一定是光束得占用最长的圆弧度数，想想就明白，光束一定与移动到外围圆，就比如图中下面那个绿色的圆，相切。也即可以看成是宽度为w+r的光束与红圈相切。

​	借下某位大佬的示意图

​	![1581826760296](\JODE-HRK.github.io\assets\image\洛谷 春季多校 Final Spark2.png)

```c++
#include <bits/stdc++.h>
using namespace std;
int T, w, t, s, d;
double theata;
int main()
{
	scanf("%d", &T);
	while (T--)
	{
		scanf("%d %d %d %d", &w, &t, &s, &d);
		int wt = w + t;
		int p = wt >= s ? 1 : 0;
		if (wt >= 2 * s)
		{
			printf("1.000000000\n");
			continue;
		}
		if (wt == 0)//注意上面两个
		{
			printf("0.000000000\n");
			continue;
		}
		theata = acos((double)(s - wt) / (double)(s));//以后不要随意+double。。只要加一个就可以了
		printf("%.9lf\n", theata / acos(-1));
	}
	return 0;
}
```

