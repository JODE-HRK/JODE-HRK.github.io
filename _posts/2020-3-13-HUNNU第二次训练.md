---
title: 2020 春季 HUNNU第二次训练
tags:
  - C++
  - ACM
  - 算法竞赛
  - 动态规划

---

## 2020 春季 HUNNU第二次训练

**A Rational Sequence (Take 3)**

题意：一棵树，在1号根节点，p=1,q=1,其值为 p/q。每个节点的左节点为 p/（p+q） ，右节点为 （p+q）/q。要你求n号节点的值。

分析：很简单，用栈保存，然后一步步往上存就可以了。

```c++
#include <bits/stdc++.h>
using namespace std;
int n, p = 1, q = 1, id, cnt;
stack<int> Q;
int main()
{
    scanf("%d", &n);
    while (n--)
    {
        p = q = 1;
        scanf(" %d %d", &cnt, &id);
        while (id > 1)
        {
            if (id % 2)
                Q.push(1); //1右
            else
                Q.push(0); //0左
            id /= 2;
        }
        while (!Q.empty())
        {
            int x = Q.top();
            Q.pop();
            if (x)
                p = p + q;
            else
                q = p + q;
        }
        cout << cnt << ' ' << p << '/' << q << endl;
    }
    return 0;
}
```

**Which Base is it Anyway?**

题意：每给你一个数，让你转换成8进制、10进制、16进制。

分析：简单，但是我这里采用了字符串的转换方式。中间那个if是在搞了我好久。

```c++
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
int t, id, n;
char str[10];
int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &id);
        scanf("%s", str);
        int Octa = -1, Dec = 0, hex = 0;
        char *stop = NULL;
        Octa = strtol(str, &stop, 8);//strol(要转的字符串,转换停止的地方,转换的进制)
        if (*stop != '\n' && *stop != '\000')//stop会停止在不合法或者转换完全之后的位置
            Octa = 0;//此处是8进制不合法，就变成0
        Dec = strtol(str, &stop, 10);
        hex = strtol(str, &stop, 16);
        printf("%d %d %d %d\n", id, Octa, Dec, hex);
    }
    return 0;
}
```

**m-ary Partitions**

题意：给你一个数n，和一个底数m，要求你用m的次方数组成n，看有多少种组成方法。

分析：简单背包，因为结果满足一个32为的无符号整型，故使用long long

```c++
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <cstdlib>
#include <vector>
#define ll long long
using namespace std;
const int maxn = 1e4 + 7;
int t, id;
ll n, m;
int main()
{
	scanf("%d", &t);
	while (t--)
	{
		ll dp[maxn];
		memset(dp, 0, sizeof(dp));
		dp[0] = 1;
		scanf("%d %lld %lld", &id, &m, &n);
		for (int i = 1; i <= n; i *= m)
			for (int j = i; j <= n; j++)
				dp[j] += dp[j - i];
		// cout << dp[n];
		printf("%d %lld\n", id, dp[n]);
	}
	return 0;
}
```



