---
title: Ardenia
tags:
  - ACM
  - 算法竞赛
  - 图论
  - 最大流
---

# 洛谷P3376 模板题

原本这是我几年前做过的题目，但昨天发现原来的代码过不了了，应该是洛谷对数据进行了加强。然后我发现，我原本代码的dfs只搜到了一条有效线路就直接返回了，所以在原来的哪里修改了，dfs把当前能走的全部走完。

原来的代码：

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 7;
int n, m, s, t, cnt = 0;
int dis[maxn], head[maxn];
struct Edge
{
    int to, w, nxt;
} edge[maxn];
bool vis[maxn];
bool bfs() //bfs判断是否能继续走到汇点
{
    fill(dis, dis + 1 + n, -1);
    queue<int> Q;
    Q.push(s);
    dis[s] = 0;
    while (!Q.empty())
    {
        int now = Q.front();
        Q.pop();
        for (int i = head[now]; ~i; i = edge[i].nxt)
        {
            int v = edge[i].to;
            if (edge[i].w > 0 && dis[v] == -1)
            {
                dis[v] = dis[now] + 1;
                if (v == t)
                    return 1;
                Q.push(v);
            }
        }
    }
    return 0;
}
int cur[maxn]; //弧优化，，cur数组记录上一次dfs增广时 u已经增广到了第几条边，从而优化时间
int dfs(int st, int flow)
{
    if (t == st)
        return flow;
    for (int i = cur[st]; ~i; i = edge[i].nxt)
    {
        int v = edge[i].to;
        if (dis[v] == dis[st] + 1 && edge[i].w > 0)
        {
            int k = dfs(v, min(flow, edge[i].w));
            if (k)//此处只搜到了一条线路就返回了
            {
                edge[i].w -= k;
                edge[i ^ 1].w += k;
                return k;
            }
        }
    }
    return 0;
}
void init()
{
    for (int i = 0; i <= cnt + 1; i++) //初始化cur数组，即将head数组赋给cur数组
        cur[i] = head[i];
}
int dinic()
{
    int ans = 0;  // 记录总流量
    while (bfs()) //bfs建立分层图，以便dfs增广
    {
        init();
        ans += dfs(s, 0x7fffffff); //dfs增广
    }
    return ans;
}
void add(int fr, int to, int ww)
{
    edge[cnt].to = to, edge[cnt].w = ww, edge[cnt].nxt = head[fr];
    head[fr] = cnt++;
}
int main()
{
    scanf("%d %d %d %d", &n, &m, &s, &t);
    fill(head, head + 2 + 2 * m, -1);
    for (int i = 1; i <= m; i++)
    {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        add(u, v, w);
        add(v, u, 0);
    }
    printf("%d", dinic());
    return 0;
}
```

新代码：

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 1e6 + 7;
int n, m, st, en;
struct Edge
{
    int to, nxt;
    ll w;
} edge[maxn << 1];
int head[maxn], tot = 0;
int dis[maxn];
void addEdge(int s, int c, int w)
{
    edge[tot].to = c, edge[tot].w = w, edge[tot].nxt = head[s];
    head[s] = tot++; // 必然是tot++，0号位必须占用对应下面的 ~i，不然会死循环
}
int cur[maxn << 1];
void init()
{
    for (int i = 0; i <= tot; i++)
        cur[i] = head[i];
}
bool bfs()
{
    fill(dis, dis + 1 + n, -1);
    queue<int> Q;
    while (!Q.empty())
        Q.pop();
    Q.push(st);
    dis[st] = 0;
    while (!Q.empty())
    {
        int now = Q.front();
        Q.pop();
        for (int i = head[now]; ~i; i = edge[i].nxt)
        {
            int v = edge[i].to;
            if (edge[i].w && dis[v] == -1)
            {
                dis[v] = dis[now] + 1;
                if (v == en)
                    return 1;
                Q.push(v);
            }
        }
    }
    return 0;
}
ll dfs(int s, ll flow)
{ //更快的dfs寻找增广路，其实是优化了下一个bfs
    if (s == en)
        return flow;
    ll _flow = 0, __flow;
    for (int i = cur[s]; ~i; i = edge[i].nxt)
    {
        int v = edge[i].to;
        if (dis[v] == dis[s] + 1 && edge[i].w)
        {
            __flow = dfs(v, min(flow, edge[i].w));
            flow -= __flow;
            edge[i].w -= __flow;
            _flow += __flow;
            edge[i ^ 1].w += __flow;
            if (!flow)
                break;
        }
    }
    if (!_flow)
        dis[s] = -1;
    return _flow;
}
ll Dinic()
{
    ll ans = 0;
    while (bfs())
    { //bfs构建层次网络 判断是否存在一条到en的点
        init();
        ans += dfs(st, 0x7fffffff); //一次dfs完成所有增广
    }
    return ans;
}
int main()
{
    scanf("%d %d %d %d", &n, &m, &st, &en);
    fill(head, head + 2 + 2 * m, -1);
    for (int i = 1; i <= m; i++)
    {
        int fr, to, w;
        scanf("%d %d %d", &fr, &to, &w);
        addEdge(fr, to, w);
        addEdge(to, fr, 0);
    }
    printf("%lld", Dinic());
    return 0;
}
```

代码上了，再讲讲最大流的基础知识

关于网络流的定义还有流量容量可行流，这些直接百度，我这不再多嘴（最重要的前向弧和后向弧一定要知道）

最大流算法中有一个关键步骤，就是寻找增广路，增广路的定义如下：

假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点，并且，这条路上的每一段都满足流量<容量，注意，是严格的<,而不是<=。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流。这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路。

寻找增广路就是为了一步步对流进行扩大，直到我们的网络无法再进行流的增长，这时我们就找到了最大流。

那么如何来寻找增广路呢？

这里引入的后向弧非常关键，