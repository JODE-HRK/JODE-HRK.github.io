---
title: 洛谷 2020 ACM春季多校 第五场
tags:
  - C++
  - ACM
  - 算法竞赛
  - 洛谷
---

## 洛谷 2020 ACM春季多校 第五场

A、Ammunition

题意：你可以选择n个物品，有三种物品可供选择，一种值为a，一种值为b，另一种可以在 [ 0,b/2]之间随意选择，问你选择的n个物品是否能够达到m（n个物品可以不取完。）。

分析：

​	首先我们取得最大值n * b，如果n * b < m，绝对是No。

​	再来考虑将b换成第二种值为b的物品换成b/2：

​		1、换两个：可以覆盖任何[ kb+0 , kb+2 * b/2 ]，k=0,…,n-2

​		2、换一个：可以覆盖[ (k-1)b+0 , (k-1)b+b/2 ]

​		3、不换：就是n * b

将上面的区间合并，就得到了，这n个物品可以是在 [ 0 , (n-1) * b + b/2 ] 这个区间的任何数。

​	接下来考虑将b换成a：

​		当b换成a时，值势必会减少b-a，所以当 (n * b - m) % (b-a) == 0 时，就有可能达到m，继续判断(n * b - m) / (b-a)是否小于等于n，若是则能够到达m。

```c++
#include <bits/stdc++.h>
using namespace std;
int t;
__int128_t n, m, a, b;
void read(__int128_t &X)
{
    X = 0;
    int w = 0;
    char ch = 0;
    while (!isdigit(ch))
    {
        w |= ch == '-';
        ch = getchar();
    }
    while (isdigit(ch))
        X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
    if (w)
        X = -X;
}
void print(__int128 x)
{
    if (!x)
        return;
    if (x < 0)
        putchar('-'), x = -x;
    print(x / 10);
    putchar(x % 10 + '0');
}
bool judge()
{
    if (m == 0)
        return 1;
    if (n == 0)
        return 0;
    if (n * b < m)
        return 0;
    if (n * b == m)
        return 1;
    if ((n - 1) * b + b / 2 >= m)
        return 1;
    if ((n * b - m) % (b - a) == 0)
        if ((n * b - m) / (b - a) <= n)
            return 1;
        else
            return 0;
    return 0;
}
int main()
{
    scanf("%d", &t);
    while (t--)
    {
        read(n), read(m), read(a), read(b);
        if (judge())
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}
```



B、

C、Change

题意：给你n组字符串，每组都可以选择一个字符串，问是否有一种选择方法，使得英文字母中排序为1~n的字母都出现。

分析：简单的二分图匹配问题

```c++
#include <bits/stdc++.h>
using namespace std;
int n, m;
int vis[30]; //这个数组仅标记右侧端点
int g[30][30], cz[30], cy[30];
int point(int u)
{
    for (int i = 1; i <= n; i++)
    {
        if (g[u][i] && !vis[i])
        {
            vis[i] = 1;
            if (cy[i] == -1 || point(cy[i]))
            {
                cz[u] = i;
                cy[i] = u;
                return 1;
            }
        }
    }
    return 0;
}
int main()
{
    memset(g, 0, sizeof(g));
    cin >> n;
    int u, v;
    string s;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &m);
        u = i;
        while (m--)
        {
            cin >> s;
            v = s[0] - 'a' + 1;
            g[u][v] = 1;
        }
    }
    memset(cz, -1, sizeof(cz));
    memset(cy, -1, sizeof(cy));
    int ret = 0;
    for (int i = 1; i <= n; i++)
    {
        if (cz[i] == -1)
        {
            memset(vis, 0, sizeof(vis));
            ret += point(i);
        }
    }
    if (ret == n)
        printf("Yes");
    else
        printf("No");
    return 0;
}
```



D、Duliu

题意：

分析

```c++

```



E、

F、Flaw

题意：给你一个 a + n1 < n2 或 a + n1 > n2 的不等式，问你a有多少种值满足这个不等式，情况包括溢出的情况。

​			if a+b >= 2^31, then the result is a+b-2^32。

​			n1、n2均为非负整数，且范围都在[-2147483648,2147483647]。

分析：实际上就是查询比n2大的有多少个数，或者比n2小的有多少个数。

```c++
#include <bits/stdc++.h>
using namespace std;
int n[2], cnt = 0;
string s;
int main()
{
    cin >> s;
    int p = 0, sp;
    n[0] = n[1] = 0;
    for (int i = 0; i < s.length(); i++)
    {
        if (s[i] == '<')
            p = 1, cnt++;
        if (s[i] == '>')
            p = 2, cnt++;
        if (s[i] == '+')
            sp = -1;
        if (s[i] == '-')
            sp = 1;
        if (s[i] >= '0' && s[i] <= '9')
            n[cnt] = n[cnt] * 10 + s[i] - '0';
    }
    long long ans = 0;
    if (p == 2)//符号为大于，则有且仅有
        ans = 0x7fffffff - 1ll * n[1];
    else
        ans = 1ll * 0x7fffffff + 1ll * n[1] + 1;
    printf("%lld", ans);
    return 0;
}
```



G、Gene

题意：给你两串基因序列，要你求最大的匹配值，其中匹配+a，失配-b，为gap(间隙)-c。

分析：DP，f[i] [j]表示第一个串的前i个位置和第二个串的前j个位置匹配的最大收益

​			f[i] [j] = max( max( f[i-1] [j] , f[i] [j-1] ) – gamma , f[i-1] [j-1]+( a[i]==b[j]?alpha:-beta ) )

​			初始化的时候需要初始化为f[i] [0]=f[0] [i]=-i*gamma，这里答案可能是负数，而且会爆int，注意开long long

```c++
#include <bits/stdc++.h>
using namespace std;
int n, m, a, b, c;
char s1[5001], s2[5001];
long long dp[5001][5001];
int main()
{
    scanf("%d %d %d %d %d", &n, &m, &a, &b, &c);
    cin >> s1 + 1 >> s2 + 1;
    for(int i=0;i<=n ||i<=m;i++)
        dp[i][0] = dp[0][i] = -i *1ll* c;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            dp[i][j] = max(max(dp[i - 1][j], dp[i][j - 1]) - c, dp[i - 1][j - 1] + (s1[i] == s2[j] ? a : -b));

    printf("%lld",dp[n][m]);
    return 0;
}
```



H、